# This file is part of Origame. See the __license__ variable below for licensing information.
#
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# For coding standards that apply to this file, see the project's Coding Standards document,
# r4_coding_standards.html, in the project's docs/CodingStandards/html folder.

"""
*Project - R4 HR TDP*: This package provides functionality related to the GUI variant of the Origame application.

Note: the gui package can only be used (imported) if origame.core.setup_for_qtgui() has been called.

Version History: See SVN log.
"""

import logging

from PyQt5.QtCore import QMetaObject
import matplotlib

if matplotlib.get_backend() != 'Qt5Agg':
    matplotlib.use('Qt5Agg')
matplotlib.interactive(True)

from .backend_bridge import bridge_signal, BridgeEmitter
from .safe_slot import safe_slot as __safe_slot
from .. import core

# -- Meta-data ----------------------------------------------------------------------------------

__version__ = "$Revision: 5788$"

__license__ = """This file can ONLY be copied, used or modified according to the terms and conditions
                 described in the LICENSE.txt located in the root folder of the Origame package."""
__copyright__ = "(c) Her Majesty the Queen in Right of Canada"

# -- Setup package ------------------------------------------------------------------------------

log = logging.getLogger('system')


def setup_bridge_for_qtgui():
    """
    The core.BridgeEmitter is in fact bound at runtime to an actual class that depends on the variant.
    In a pure console-based application, it is bound to BackendEmitter, a class that has an API that
    matches that of QObject (or at least the subset of it used by the backend). In a PyQt-based
    variant, it is bound to backend_bridge.BridgeEmitter, which is a class that extends QObject.
    This makes the backend components QObject-derived objects when loaded in the GUI variant.

    This function is used to bind core.BridgeEmitter to backend_bridge.BridgeEmitter and core.BridgeSignal
    to backend_bridge.bridge_signal so that the above can be achieved. Without a call to this function
    before all other GUI and backend modules are imported, the GUI will fail to start.

    Example: given the following a some_module.py:

        from origame.core import BridgeEmitter, BridgeSignal

        class FooConsoleAndGui(BridgeEmitter):
            sig_test = BridgeSignal()

            def __init__(self):
                pass

    then without a call to setup_bridge_for_qtgui(), the FooConsoleAndGui in fact derives from BackendEmitter.
    However, if the setup_bridge_for_qtgui() is called before the import line, ie:

        import origame.gui
        from origame.core import BridgeEmitter, BridgeSignal

        class FooConsoleAndGui(BridgeEmitter):
            sig_test = BridgeSignal()

            def __init__(self):
                pass

    then FooConsoleAndGui in fact derives from backend_bridge.BridgeEmitter (which derives from QObject)
    and sig_test is either pyqtSignal() or backend_bridge.BridgeSignalExt().

    Notes:
    - setup_bridge_for_qtgui() only needs to be called once in the whole application, because Python
      guarantees that modules only get imported once (further imports use the already-imported module).
    - GUI classes (anything under the "gui" package) must continue to use QObject and pyqtSignal directly.
      The bridge is only to bridge the GUI to the backend.
    """
    core.BridgeSignal = bridge_signal
    core.signaling.BridgeSignal = bridge_signal

    core.BridgeEmitter = BridgeEmitter
    core.signaling.BridgeEmitter = BridgeEmitter

    core.safe_slot = __safe_slot
    core.signaling.safe_slot = __safe_slot


# ---------------------------------------------------------------------------------------
#
#  ---> WARNING all other imports from origame must come AFTER setup_bridge_for_qtgui <-------
#
#        so the gui package must be the first origame import in Origame GUI variant
#
# ---------------------------------------------------------------------------------------
setup_bridge_for_qtgui()


def connectSlotsByName(widget):
    """
    PyQt's builtin QMetaObject.connectSlotsByName() is automatically included in all
    files generated by PyUIC: this automatically connects signals of a widget to any of its methods that have a
    name of the form "on_OBJ_SIGNAL" where obj is the widget name and SIGNAL is a signal available for the widget
    type. Unfortunately there is no way to prevent PyUIC from inserting a call to QMetaObject.connectSlotsByName(),
    or to turn off QMetaObject.connectSlotsByName()

    Hence this function designed to replace the QMetaObject method: for origame modules, it does nothing, thus
    preventing auto-connection from occurring in any widget class created for Origame; for classes defined in
    modules outside of origame.gui, the original QMetaObject method is called.

    By having the replacement occur at GUI package level, any Python script that imports from
    origame.gui has auto-connections disabled for the origame.gui components only.
    """
    if r'origame.gui' in widget.__class__.__module__:
        # log.debug('Origame widgets must not use Qt\'s auto-connection feature')
        pass
    else:
        __orig_QMetaObject_connectSlotsByName(widget)


# save the original QMetaObject.connectSlotsByName for non-Origame modules
assert QMetaObject.connectSlotsByName != connectSlotsByName
__orig_QMetaObject_connectSlotsByName = QMetaObject.connectSlotsByName
QMetaObject.connectSlotsByName = connectSlotsByName

# -- PUBLIC API ---------------------------------------------------------------------------------
# import *public* symbols (classes/functions/constants) from contained modules:

from ..core import BridgeEmitter
# sanity check that setup_bridge_for_qtgui() was called:
from ..core import BackendEmitter as __BackendEmitter

assert BridgeEmitter is not __BackendEmitter

from .mainwindow import MainWindow
