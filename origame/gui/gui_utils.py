# This file is part of Origame. See the __license__ variable below for licensing information.
#
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# For coding standards that apply to this file, see the project's Coding Standards document,
# r4_coding_standards.html, in the project's docs/CodingStandards/html folder.

"""
*Project - R4 HR TDP*:  This module is used to provide access to common operations to GUI classes.

Version History: See SVN log.
"""

# -- Imports ------------------------------------------------------------------------------------

# [1. standard library]
import gc
import logging
import importlib
from enum import IntEnum, unique
from pathlib import Path

# [2. third-party]
from PyQt5.QtCore import QSize, QObject, QTimer, QVariant, QMessageLogContext
from PyQt5.QtCore import QtCriticalMsg, QtFatalMsg, QtSystemMsg, QtMsgType, QtDebugMsg, QtInfoMsg, QtWarningMsg
from PyQt5.QtCore import pyqtSlot, pyqtSignal, Qt, QModelIndex, QAbstractTableModel
from PyQt5.QtGui import QIcon, QPixmap, QFont, QFontMetricsF, QColor, QBrush, QShowEvent, QValidator
from PyQt5.QtWidgets import QMessageBox, QToolButton, QAction, QWidget, QListWidgetItem
from PyQt5.QtWidgets import QSizePolicy, QLineEdit, QCheckBox

# [3. local]
from ..core import override_required, override
from ..core.typing import AnnotationDeclarations
from ..core.typing import Any, Either, Optional, Callable, PathType, TextIO, BinaryIO
from ..core.typing import List, Tuple, Sequence, Set, Dict, Iterable, Stream
from ..core.utils import get_verified_eval

from ..scenario import Scenario, ScenarioManager
from ..scenario.defn_parts import get_pretty_type_name, is_path_below_directory, check_valid_file_path

from .safe_slot import safe_slot
from .async_methods import AsyncRequest
from .constants import DETAILED_PARAMETER_SYNTAX_DESCRIPTION


# -- Meta-data ----------------------------------------------------------------------------------

__version__ = "$Revision: 5800$"
__license__ = """This file can ONLY be copied, used or modified according to the terms and conditions
                 described in the LICENSE.txt located in the root folder of the Origame package."""
__copyright__ = "(c) Her Majesty the Queen in Right of Canada"

# -- Module-level objects -----------------------------------------------------------------------


# It is pointless to have an _all_ for this module since everything is public
# Prefix non-public things with _


log = logging.getLogger('system')

# This widget size constant is auto-generated by the UI-code
# It is parameterized here for use within the R4 code
QWIDGETSIZE_MAX = 16777215

# QGraphicsItem does not have name property, but it can use setData() to set any properties such as name. Names
# can facilitate many tasks. Testing is one of them.
OBJECT_NAME = 0

TEXT_LINK_PRESENT_COLOR = QColor(0, 255, 0).lighter(160)
TEXT_LINK_MISSING_COLOR = QColor(255, 0, 0).lighter(160)
LIST_REGULAR_BRUSH = QBrush(QColor(Qt.black))
UNUSED_LINK_HIGHLIGHTING_BRUSH = QBrush(QColor(Qt.gray))
NEW_LINK_HIGHLIGHTING_BRUSH = QColor(0, 255, 0).darker(120)
HIGHLIGHTED_BORDER_COLOR = QColor(0, 255, 0, 150)  # Color for the selected part
DEPRECATION_ALPHA = 128  # Title bar transparency color setting for deprecated parts
IFX_TEXT_COLOR = QColor(255, 255, 255)
IFX_TEXT_SIZE = 10
IFX_BAR_TEXT_SIZE = 11
IFX_PORT_NAME_WIDTH = 60  # Will be re-evaluated by the QFontMetricsF

HORIZONTAL_ELLIPSIS = u'\u2026'

# When a part is selected, a green margin is added. Its width is specified by this attribute.
MARGIN_OF_SELECTED_PART = 5.0

# When the proximity boundary is triggered or the item is selected, add this much to the base item.
PROXIMITY_MARGIN_LEFT = 10.0
PROXIMITY_MARGIN_RIGHT = 10.0
PROXIMITY_MARGIN_TOP = 10.0
PROXIMITY_MARGIN_BOTTOM = 10.0

# Space between items. Mostly used in the side items.
ITEM_SPACE = 2.0

LINK_CREATION_SHORTCUT_SPACE = 4.0

PART_ITEM_BORDER_WIDTH = 4  # The width of the border surrounding the part

EVENT_COUNTER_RECT_HEIGHT = 20
EVENT_COUNTER_ARROW_WIDTH = EVENT_COUNTER_RECT_HEIGHT / 2

LINK_CREATION_ACTION_ITEM_WIDTH = 20
LINK_CREATION_ACTION_ITEM_HEIGHT = EVENT_COUNTER_RECT_HEIGHT

# Styles
HOVER_EFFECT = ":!hover{background-color: rgba(222, 222, 222, 255);}:hover{background-color: rgba(255, 255, 255, 255);}"

ICON_PATH = Path(__file__).parent / "icons"
FONT_PATH = Path(__file__).parent / "fonts"

# Deja Vu Sans Mono is the preferred font for scripting, but it is not shipped with the Qt. So, we load it in the app.
DEFAULT_FONT_MONO_PATH = str(FONT_PATH.joinpath('dejavu-fonts-ttf-2.37', 'ttf', 'DejaVuSansMono.ttf'))
DEFAULT_FONT_MONO = None
DEFAULT_FONT = None

QTBUG_55918_OPACITY = 0.99999  # set this opacity on ALL graphics items that derive from QGraphicsWidget

BUTTON_ICON_PIXMAPS = {
    'cancel': "cancel.png",
    'link': "link_valid.png",
    'clear': "clear_queue.png",
    'delete': "delete.png",
}

PART_ICON_PIXMAPS = {
    'actor': "part_actor.svg",
    'actor_proxy': "part_actor_proxy.svg",
    'button': "part_button.svg",
    'clock': "part_clock.svg",
    'datetime': "part_datetime.svg",
    'data': "part_data.svg",
    'database': "part_database.svg",
    'file': "part_file.svg",
    'function': "part_function.svg",
    'hub': "part_hub.svg",
    'info': "part_info.svg",
    'interface': "part_ifx.svg",
    'multiplier': "part_multiplier.svg",
    'node': "part_node.svg",
    'plot': "part_plot.svg",
    'pulse': "part_pulse.svg",
    'read': "part_readtext.svg",
    'sql': "part_sql.svg",
    'library': "part_library.svg",
    'link': "part_link.svg",
    'sheet': "part_sheet.svg",
    'table': "part_table.svg",
    'time': "part_time.svg",
    'variable': "part_variable.svg",
    'waypoint': "waypoint.svg",
    'write': "part_writetext.svg"
}

# Could these be calculated in a function based on the color of pixel 1,1 of a given pixmap?
# For now they're just constants I set from the color picker values.
PART_ICON_COLORS = {
    'actor': QColor(212, 0, 0),
    'actor_proxy': QColor(159, 150, 150),
    'button': QColor(188, 90, 0),
    'clock': QColor(223, 23, 137, DEPRECATION_ALPHA),
    'datetime': QColor(223, 23, 137),
    'data': QColor(3, 136, 0),
    'database': QColor(0, 106, 65),
    'file': QColor(122, 118, 35),
    'function': QColor(0, 102, 255),
    'hub': QColor(118, 118, 118),
    'info': QColor(231, 231, 231),
    'interface': QColor(118, 118, 118),
    'library': QColor(0, 102, 255),
    'link': QColor(80, 80, 80, 255),     #0, 0, 0, 175
    'node': QColor(118, 118, 118),
    'multiplier': QColor(118, 118, 118),
    'plot': QColor(188, 90, 0),
    'pulse': QColor(223, 23, 137),
    'read': QColor(122, 118, 35),
    'sheet': QColor(3, 136, 0),
    'sql': QColor(0, 102, 255),
    'table': QColor(0, 106, 65),
    'time': QColor(223, 23, 137),
    'variable': QColor(3, 136, 0),
    'waypoint': QColor(80, 80, 80),    #192, 192, 192
    'write': QColor(122, 118, 35),
}

# Matches the PART_ICON_COLORS except for the info, node, hub, and multiplier
IFX_BACKGROUND_COLOR = {
    'actor': PART_ICON_COLORS['actor'],
    'button': PART_ICON_COLORS['button'],
    'clock': PART_ICON_COLORS['clock'],
    'datetime': PART_ICON_COLORS['datetime'],
    'data': PART_ICON_COLORS['data'],
    'database': PART_ICON_COLORS['database'],
    'file': PART_ICON_COLORS['file'],
    'function': PART_ICON_COLORS['function'],
    'hub': QColor(150, 150, 150),
    'info': PART_ICON_COLORS['info'],
    'library': PART_ICON_COLORS['library'],
    'node': QColor(150, 150, 150),
    'multiplier': QColor(150, 150, 150),
    'plot': PART_ICON_COLORS['plot'],
    'pulse': PART_ICON_COLORS['pulse'],
    'read': PART_ICON_COLORS['read'],
    'sheet': PART_ICON_COLORS['sheet'],
    'sql': PART_ICON_COLORS['sql'],
    'table': PART_ICON_COLORS['table'],
    'time': PART_ICON_COLORS['time'],
    'variable': PART_ICON_COLORS['variable'],
    'write': PART_ICON_COLORS['write'],
}

QT_LOG_MSG_TYPES = {
    QtDebugMsg: "debug",
    QtInfoMsg: "info",
    QtWarningMsg: "warning",
    QtCriticalMsg: "critical",
    QtFatalMsg: "fatal",
    QtSystemMsg: "system"
}

CheckerFunc = Callable[..., bool]
OnCheckTrueCB = Callable[..., bool]
OnCheckExpiredCB = Callable[..., bool]


class Decl(AnnotationDeclarations):
    PyExpr = 'PyExpr'

# int: row; int: column
PyExprGridCache = Dict[int, Dict[int, Decl.PyExpr]]

# -- Function definitions -----------------------------------------------------------------------


def install_default_fonts(default_fnt: QFont, default_fnt_mono: QFont):
    """
    Installs two fonts for different purposes.
    :param default_fnt: The font used for most cases
    :param default_fnt_mono: The font used for displaying and editing script related texts.
    """
    global DEFAULT_FONT
    DEFAULT_FONT = default_fnt
    global DEFAULT_FONT_MONO
    DEFAULT_FONT_MONO = default_fnt_mono

    global IFX_PORT_NAME_WIDTH
    app_font_metrics = get_app_font_metrics(point_size=IFX_TEXT_SIZE, mono=True, stretch=QFont.SemiCondensed)
    MAX_NUM_CHARS_IFX_PORT = 8  # ifx ports only show first (left-most) N chars of the associated part name
    IFX_PORT_NAME_WIDTH = app_font_metrics.width("W" * MAX_NUM_CHARS_IFX_PORT + "  ")


def set_default_dialog_frame_flags(win_obj: QWidget):
    """
    Removes context help "?" button from the given object, and adds min and max buttons to it.
    :param win_obj: The object whose window flags will be changed by this function.
    """
    win_obj.setWindowFlags(win_obj.windowFlags() & ~Qt.WindowContextHelpButtonHint | Qt.WindowMinMaxButtonsHint)


def get_scenario_font(point_size: int = None, bold: bool = False, mono: bool = False,
                      stretch: int = QFont.Unstretched):
    """Get the non-default font to be used by application"""
    if mono:
        from_default = QFont(DEFAULT_FONT_MONO)
    else:
        from_default = QFont(DEFAULT_FONT)

    if point_size is not None:
        from_default.setPointSize(point_size)
    from_default.setBold(bold)
    from_default.setStretch(stretch)
    return from_default


def get_app_font_metrics(point_size: int = None, bold: bool = False, mono: bool = False,
                         stretch: int = QFont.Unstretched):
    """Get the non-default font metrics to be used by application"""
    return QFontMetricsF(get_scenario_font(point_size, bold, mono, stretch))


def get_ifx_port_name_width():
    return IFX_PORT_NAME_WIDTH


def qt_log_catcher(msg_type: QtMsgType, context: QMessageLogContext, msg: str):
    """
    Attempt to catch error by Qt
    :param msg_type: The type of the message from the Qt
    :param context: The context of the message from the Qt
    :param msg: The message itself
    """
    log.info("{} from Qt: {}", QT_LOG_MSG_TYPES[msg_type].upper(), msg)

    context_items = []
    for attr in dir(context):
        if not attr.startswith('_'):
            value = getattr(context, attr)
            if value:
                context_items.append("{}={}".format(attr, value))

    if context_items:
        log.info("    (context: {})", ', '.join(context_items))


def show_modal_dialog(title_text: str, informative_text: str) -> QMessageBox:
    """
    Accessory helper method to show a modal dialog (QMessageBox) where no user response is required.
    Use this dialog to display messages to the user where the dialog will be closed progamatically. Since the dialog
    is modal, the user will not be able to interact with the application until the dialog closes.
    :param title_text: title to be displayed.
    :param informative_text: informative text to be displayed.
    :return prompt: the prompt dialog object.
    """
    prompt = QMessageBox()
    prompt.setText(title_text)
    prompt.setInformativeText(informative_text)
    prompt.setStandardButtons(QMessageBox.NoButton)
    prompt.show()
    return prompt


class CustomMessageBox(QMessageBox):
    """
    The default QMessageBox is sized according to the text of the message, which often makes the details
    box too small and awkward to use. This extension is a hacked message box that can have a minimum width.

    HOWEVER: Based on Qt bug board, QMessageBox was designed to be fixed width, so any workaround is a hack.
    In particular, it appears that details box may be deprecated.

    The solutions found:

    - override showEvent to set the details text box width and size policy to get desired effect
    - override the style of details box
    - show resizer and intercept it to allow resizing
    - add spaces to the text so it is wider
    - create new dialog
    """

    def __init__(self, *args, min_width=None, **kwargs):
        self.__width = min_width
        QMessageBox.__init__(self, *args, **kwargs)

    def showEvent(self, event: QShowEvent):
        super().showEvent(event)
        if self.__width:
            details_box = self.findChild(QWidget, "qt_msgbox_informativelabel")

            text_field = self.findChild(QWidget, "qt_msgbox_label")
            # resize it:
            cur_width = text_field.width()
            text_field.setMinimumWidth(self.__width)
            text_field.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            # move it so it stays centered:
            new_width = text_field.width()
            self.move(int(self.pos().x() - (new_width - cur_width) / 2), int(self.pos().y()))


def exec_modal_dialog(dialog_title: str,
                      message: str,
                      icon: QMessageBox.Icon,
                      buttons: List[QMessageBox.StandardButton] = None,
                      buttons_str_role: List[Tuple[str, int]] = None,
                      parent: QWidget = None,
                      detailed_message: str = None,
                      default_button: QMessageBox.StandardButton = None) -> QMessageBox.StandardButton:
    """
    Accessory helper method to exec a modal dialog (QMessageBox) where user response is required.
    Use this dialog to display messages to the user where a user response is required to close the dialog. Since the
    dialog is modal, the user will not be able to interact with the application until the dialog closes. A list of
    StandardButton's may be provided to allow for user interaction with the dialogue. The default button is 'OK' unless
    the icon specified is a QMessageBox.Question, in which case the default is 'Yes' and 'No'.

    :param dialog_title: title to be displayed on the top of the dialog's window.
    :param message: the message to be displayed.
    :param icon: a QMessageBox.Icon: NoIcon, Question, Information, Warning, or Critical. If 'buttons' is
        None, buttons appropriate for the icon are added to the message box.
    :param buttons: [optional] a list of QMessageBox.StandardButton's to be displayed. Default is 'OK' unless the icon
        specified is a QMessageBox.Question, in which case the default is 'Yes' and 'No'.
    :param buttons_str_role:  [optional] buttons that are added to the box in str and role.
    :param parent: [optional] The widget from which the message box is spawned.
    :param detailed_message: [optional] if provided, the 'Details...'  button will appear and display this text if
        pressed.
    :param default_button: The button to be activated when the Enter key is pressed.
    :return: the exec() result of the dialog.
    """
    MIN_DETAILS_LEN = 80
    if detailed_message and len(message) < MIN_DETAILS_LEN:
        # Bug or limitation of QMessageBox means that if message is short, but details message has a line that
        # is long, the details will be quite narrow and hence difficult to read.

        # find longest line and stretch message to match it:
        len_longest = max(len(line) for line in detailed_message.splitlines())
        len_message = len(message)
        if len_message < len_longest:
            message += ' ' * (len_longest - len_message)

    msg_box = QMessageBox(icon, dialog_title, message, parent=parent)

    if detailed_message:
        msg_box.setDetailedText(detailed_message)

    if buttons is None and buttons_str_role is None:
        default_buttons = []
        if icon == QMessageBox.Question:
            msg_box.addButton(QMessageBox.Yes)
            msg_box.addButton(QMessageBox.No)
            default_buttons.append(QMessageBox.Yes)
            default_buttons.append(QMessageBox.No)
        else:
            msg_box.addButton(QMessageBox.Ok)
            default_buttons.append(QMessageBox.Ok)

        if default_button is not None:
            if default_button not in default_buttons:
                raise ValueError('Cannot set default button: This dialog does not contain the button.')
            msg_box.setDefaultButton(default_button)

    else:
        if buttons is not None:
            for button in buttons:
                if button == QMessageBox.NoButton:
                    raise ValueError('NoButton is not a valid button for this dialog.')
                msg_box.addButton(button)

        if buttons_str_role is not None:
            for button_str, button_role in buttons_str_role:
                msg_box.addButton(button_str, button_role)

    button_pressed = msg_box.exec()
    return button_pressed


def get_input_error_description(error: Exception):
    """
    Converts the error into plain English description.
    :param error: The error that is caused by the eval() failures
    :return: The description formatted in plain English
    """
    max_detail_line_len = 0
    for line in DETAILED_PARAMETER_SYNTAX_DESCRIPTION.split('\n'):
        if len(line) > max_detail_line_len:
            max_detail_line_len = len(line)

    FONT_STRETCH = 1.5  # spaces in font of summary portion of dialog are smaller than in details
    if isinstance(error, SyntaxError):
        msg = 'Input "{}" invalid syntax starting at {} ({})'.format(error.text, error.offset, error.msg)
    else:
        msg = 'Input "{}" failed evaluation: {}'.format(error.text, str(error).capitalize())

    padding_spaces = int((max_detail_line_len - len(msg)) * FONT_STRETCH) * ' '
    if padding_spaces:
        msg += padding_spaces

    return msg


def exec_modal_input_error_dialog(error: Exception):
    """
    Shows a modal dialog telling the user the input value has a syntax error, for example, the error that cannot
    pass the eval() check.
    :param error: The error that explains why the value is wrong.
    """
    exec_modal_dialog("Input Error",
                      get_input_error_description(error),
                      QMessageBox.Critical,
                      default_button=QMessageBox.Ok,
                      detailed_message=DETAILED_PARAMETER_SYNTAX_DESCRIPTION)


def get_icon_path(file_name: str) -> str:
    """
    :param file_name optional filename for appending to the returned Path
    :return: Absolute Path to gui icons directory.
    """
    return str(ICON_PATH / file_name)


def check_icons_same_pixels(icon1: QIcon, icon2: QIcon, width: int = 1000, height: int = 1000):
    """
    Checks if the two icons have identical images.
    :param icon1: The icon to be compared.
    :param icon2: The icon to be compared.
    :param width: The width of the image.
    :param height: The height of the image.
    :return: True - two icons have the same image.
    """
    return icon1.pixmap(width, height).toImage() == icon2.pixmap(width, height).toImage()


def part_image(part_type: str) -> Path:
    """
    :param part_type: The part type
    :return: absolute Path of pixmap for that part type
    """
    return ICON_PATH / PART_ICON_PIXMAPS[part_type]


def part_comment_bubble_button_image() -> Path:
    """
    :return: absolute Path of pixmap for the comment bubble image
    """
    return ICON_PATH / "marker_comment.svg"


def set_button_image(button: QToolButton, image_path: str, size: QSize = None, resize: bool = False, margin: int = 10,
                     text: str = None, style: int = 3):
    """
    Utility method set the background image for a particular button.
    :param button: The button on which to set the image.
    :param image_path: The path to the icon.
    :param size: [optional] Set the desired size of the image directly.
    :param resize: [optional] Flag to adjust the icon size to the given margin (alternative to 'size').
    :param margin: [optional] Margin to adjust the icon image size.
    :param text:  [optional] Button text to display.
    :param style: [optional] Style (Qt::ToolButtonStyle) indicates where text goes:
        0=icon only, 1=text only, 2=text to right of icon, 3=text below icon, 4=use the QStyle hint.
    """

    pix_map = QPixmap(str(image_path))
    icon = QIcon(pix_map)
    button.setIcon(icon)

    if size:
        button.setIconSize(size)

    if resize:
        height = button.height() - margin
        width = button.width() - margin
        q_size = QSize(int(height), int(width))
        button.setIconSize(q_size)

    if text:
        button.setText(text)
        button.setToolButtonStyle(style)


def try_disconnect(signal: pyqtSignal, slot: pyqtSlot):
    try:
        signal.disconnect(slot)
    except TypeError:
        pass


def retrieve_cached_py_expr(model: QAbstractTableModel,
                            cache: Dict[str, Decl.PyExpr],
                            idx: QModelIndex,
                            obj: Any) -> Decl.PyExpr:
    """
    Retrieves the PyExpr object that represents the obj from the cache. If the cached object
    cannot be found, this function creates and caches it.
    :param model: The model to be notified of the completion of the PyExpr construction
    :param cache: The cache maintained by the caller
    :param idx: The index from Qt
    :param obj: The candidate for the cache
    :return: The PyExpr that wraps the original object.
    """
    # Derive a cache key from idx
    key = '{}-{}'.format(idx.row(), idx.column())
    cached_py_expr = cache.get(key)
    if cached_py_expr is not None:
        if cached_py_expr.pending:
            return cached_py_expr
        else:
            if cached_py_expr.obj == obj:
                # Already cached
                return cached_py_expr

    cache[key] = PyExpr(pending=True)

    def __construct_py_expr():
        return PyExpr(obj)

    def __constructed(py_expr):
        cache[key] = py_expr
        model.dataChanged.emit(idx, idx)

    AsyncRequest.call(__construct_py_expr, response_cb=__constructed)
    return cache[key]


# -- Class Definitions --------------------------------------------------------------------------

@unique
class CustomListWidgetItemEnum(IntEnum):
    undefined, editor_link_item = range(QListWidgetItem.UserType, QListWidgetItem.UserType + 2)


assert CustomListWidgetItemEnum.undefined == QListWidgetItem.UserType


class PartAction(QAction):
    """ A QAction for operating on a part-type. Sets the icon and data consistently. """

    def __init__(self, part_type: str, parent: QObject = None):
        super().__init__(get_pretty_type_name(part_type), parent)
        self.setData(part_type)
        self.setIcon(QIcon(str(part_image(part_type))))


class GarbageCollector(QObject):
    """
    Disable automatic garbage collection and instead collect manually
    every INTERVAL_MSEC milliseconds.

    This is done to ensure that garbage collection only happens in the GUI
    thread, as otherwise Qt can crash.

    Note: Taken from http://www.riverbankcomputing.com/pipermail/pyqt/2011-August/030378.html
    """

    INTERVAL_MSEC = 5000

    def __init__(self, parent: QObject, debug: bool = False):
        QObject.__init__(self, parent)
        self.debug = debug

        self.threshold = gc.get_threshold()
        gc.disable()
        QTimer.singleShot(self.INTERVAL_MSEC, self.check)
        # gc.set_debug(gc.DEBUG_SAVEALL)

    def check(self):
        # return self.debug_cycles()
        l0, l1, l2 = gc.get_count()
        if self.debug:
            log.debug('gc_check called: {}, {}, {}', l0, l1, l2)

        if l0 > self.threshold[0]:
            num = gc.collect(0)
            if self.debug:
                log.debug('collecting gen 0, found: {} unreachable', num)

            if l1 > self.threshold[1]:
                num = gc.collect(1)
                if self.debug:
                    log.debug('collecting gen 1, found: {} unreachable', num)

                if l2 > self.threshold[2]:
                    num = gc.collect(2)
                    if self.debug:
                        log.debug('collecting gen 2, found: {} unreachable', num)

        QTimer.singleShot(self.INTERVAL_MSEC, self.check)

    def debug_cycles(self):
        gc.collect()
        for obj in gc.garbage:
            print(obj, repr(obj), type(obj))


PLOT_UPDATE = str(get_icon_path("shortcut_refresh.svg"))
DEFAULT_BUTTON_DOWN = str(get_icon_path("button_image_down.svg"))
DEFAULT_BUTTON_UP = str(get_icon_path("button_image_up.svg"))
DEFAULT_BUTTON_ON = str(get_icon_path("button_image_on.svg"))
DEFAULT_BUTTON_OFF = str(get_icon_path("button_image_off.svg"))
DEFAULT_ACTOR_IMAGE = str(get_icon_path("default_cube.png"))
ACTOR_IMAGE_NOT_FOUND = str(get_icon_path("default_cube_not_found.png"))
BUTTON_IMAGE_NOT_FOUND = str(get_icon_path("button_image_not_found.png"))


class IScenarioMonitor:
    """
    Use this class to monitor Scenario Manager for new scenario. The derived class need only provide the
    implementation for _replace_scenario.
    """

    def __init__(self, scen_manager: ScenarioManager, auto_monitor: bool = False):
        self.__scen_manager = scen_manager
        if auto_monitor:
            self._monitor_scenario_replacement()

    def _monitor_scenario_replacement(self):
        """
        Connects to the scen_manager's sig_scenario_replaced signal, and calls self._replace_scenario
        if there already is a scenario loaded.
        """
        self.__scen_manager.signals.sig_scenario_replaced.connect(self.__slot_on_scenario_replaced)
        if self.__scen_manager.scenario is not None:
            self._replace_scenario(self.__scen_manager.scenario)

    @override_required
    def _replace_scenario(self, scenario: Scenario):
        """Derived class must implement this method"""
        raise NotImplementedError

    def __on_scenario_replaced(self):
        """Take action when scenario replaced: call overridden self._replace_scenario()"""
        self._replace_scenario(self.__scen_manager.scenario)

    __slot_on_scenario_replaced = safe_slot(__on_scenario_replaced)


class ConditionChecker(QObject):
    """
    Repeatedly check for a condition, and when condition becomes true, call a specified function; if condition
    remains false for more than a specified time, and an "on expired" function was specified, call it instead.
    If the checker was set to loop after either of these events, start over; otherwise, the object does nothing.
    Example:

        c1 = ConditionChecker(lambda: random() > 0.5, loop_on_true=True, loop_on_expired=True)
        c1.set_callback_on_true(print, 'mission accomplished')
        c1.set_callback_on_expired(print, 'failed to get random > 0.5 in less than 10 seconds')
        c1.start()   # will very likely print mission accomplished

    The checker function must be given at construction and cannot be changed (it is part of the "identity" of the
    instance -- create a new instance for the new function of the checker should be changed).
    The "on condition true" callback can be set at construction if no args/kwargs need to be given to it. Otherwise,
    use the set_callback_on_true. Same goes for the "on expired" callback.
    """

    def __init__(self, checker_func: CheckerFunc, *checker_args, interval_msec=50, max_wait_sec=5,
                 callback_on_true=None, callback_on_expired=None, loop_check=False, loop_expire=False,
                 **checker_kwargs):
        """
        :param checker_func: the callable that returns true when condition verified, and false when not
        :param checker_args: call args for checker_func
        :param interval_msec: at what interval to check for condition
        :param max_wait_sec: maximum time to wait for condition to become true
        :param callback_on_true: callable to call (without any args/kwargs) when condition becomes true
        :param callback_on_expired: callable to call (without any args/kwargs) when max_wait_time elapses after start()
        :param loop_check: if set to True, will cause automatic call to start() after condition is true
        :param loop_expire: if set to True, will cause automatic call to start() after condition fails to become
            true in less than max_wait_sec
        :param checker_kwargs: kwargs when calling checker_func()
        """
        super().__init__()
        self.__on_true_callback = None
        self.__on_expiry_callback = None
        if callback_on_true is not None:
            self.set_callback_on_true(callback_on_true)
        if callback_on_expired is not None:
            self.set_callback_on_true(callback_on_expired)

        self.__loop_on_true = loop_check
        self.__loop_on_expired = loop_expire
        self.__checker_fn = lambda: checker_func(*checker_args, **checker_kwargs)
        self.__id = "{} (args={}, kwargs={})".format(checker_func.__qualname__, checker_args, checker_kwargs)

        if max_wait_sec * 1000 < interval_msec:
            raise ValueError("The max_wait_sec {} is too small (must be larger than interval_sec, {} ms)"
                             .format(max_wait_sec, interval_msec))
        self.__wait_until_check_timer = QTimer()
        self.__wait_until_check_timer.setInterval(interval_msec)
        self.__wait_until_check_timer.timeout.connect(self.__slot_check)

        self.__wait_until_stop_timer = QTimer()
        self.__wait_until_stop_timer.setInterval(max_wait_sec * 1000)
        self.__wait_until_stop_timer.timeout.connect(self.__slot_on_max_wait_elapsed)

    def set_callback_on_true(self, callback: OnCheckTrueCB, *args, **kwargs):
        """
        Set the callback to call, and its arguments, when the condition (specified at construction) becomes true.
        This method MUST be called between construction and start() otherwise nothing will happen when condition
        becomes true!
        """
        self.__on_true_callback = lambda: callback(*args, **kwargs)
        return self

    def set_callback_on_expired(self, callback: OnCheckExpiredCB, *args, **kwargs):
        """
        Set the callback to call, and its arguments, when the condition does not become true within maximum allowed
        time. Set to None to do nothing (ie silently "give up").
        """
        self.__on_expiry_callback = None if callback is None else lambda: callback(*args, **kwargs)
        return self

    @property
    def max_time_sec(self) -> float:
        """Get the max time allowed, in seconds."""
        return self.__wait_until_stop_timer.interval() / 1000

    @property
    def loop_on_true(self) -> bool:
        """Get whether will start again once the "on condition true" callback has been called: True if start again."""
        return self.__loop_on_true

    @loop_on_true.setter
    def loop_on_true(self, value: bool = True):
        """Set whether to start again once the "on condition true" callback has been called: True to start again."""
        self.__loop_on_true = value

    @property
    def loop_on_expired(self) -> bool:
        """Get whether will start again once the "on expired" callback has been called: True if start again."""
        return self.__loop_on_expired

    @loop_on_expired.setter
    def loop_on_expired(self, value: bool = True):
        """Set whether to start again once the "on expired" callback has been called: True to start again."""
        self.__loop_on_expired = value

    def start(self):
        """
        Start checking for the condition. If it does not become true in less than max_wait_sec, stop checking and,
        if defined, call the expiry callback.
        """
        self.__wait_until_check_timer.start()
        self.__wait_until_stop_timer.start()

    def stop(self):
        """
        Stop checking for the condition. Has no effect if already expired.
        """
        self.__wait_until_check_timer.stop()
        self.__wait_until_stop_timer.stop()

    def __check(self):
        if self.__checker_fn():
            self.stop()
            self.__on_true_callback()
            if self.__loop_on_true:
                self.start()

    def __on_max_wait_elapsed(self):
        self.stop()
        self.__on_expiry_callback()
        if self.__loop_on_expired:
            self.start()

    def __str__(self):
        return self.__id

    __slot_check = safe_slot(__check)
    __slot_on_max_wait_elapsed = safe_slot(__on_max_wait_elapsed)


class PyExpr:
    """
    A "data wrapper" class for a fields that can show "special values".
    """

    # --------------------------- class-wide data and signals -----------------------------------
    MAX_STRING_PRESENTATION = 100

    # --------------------------- class-wide methods --------------------------------------------
    # --------------------------- instance (self) PUBLIC methods --------------------------------

    def __init__(self, obj: str="", pending: bool = False):
        """
        The constructor uses the obj to initialize the all the properties of this class.
        :param obj: Anything.
        """
        # The set_obj would do the same initialization, but do it here just to avoid the PEP-8 warnings.
        # We may use None as the initial object, but "" makes the editor look better.
        self.__obj = ""
        self.__pending = pending
        self.__str_repr = repr("")
        self.__is_representable = True
        self.__reason = ""  # The reason why it is not representable.
        if pending:
            self.__reason = "Data not ready."
        else:
            self.set_obj(obj)

    def get_edit_tooltip(self):
        """
        Returns a tooltip based on the reason. The tooltip instructs the user for further actions.
        :return: The tip
        """
        if self.is_representable():
            return QVariant()
        else:
            return QVariant(self.reason + " Double-click to edit the object.")

    def get_display_tooltip(self) -> QVariant:
        """
        Returns a tooltip based on the reason. The tooltip does not instruct the user for further actions.
        :return: The tip
        """
        if self.is_representable():
            return QVariant()
        else:
            return QVariant(self.reason)

    def get_obj(self):
        return self.__obj

    def set_obj(self, val):
        self.__obj = val
        self.__str_repr = repr(val)
        try:
            eval(self.__str_repr)
            obj_len = len(self.__str_repr)
            self.__is_representable = obj_len < PyExpr.MAX_STRING_PRESENTATION
            if self.__is_representable:
                self.__reason = ""
            else:
                self.__reason = "Too long (Length={}). ".format(obj_len)
        except Exception as e:
            self.__is_representable = False
            self.__reason = "No Python expression possible. "

    def get_str_repr(self) -> str:
        return self.__str_repr

    def set_str_repr(self, val: str):
        if self.__str_repr == val:
            return

        self.__obj = get_verified_eval(val)
        self.__str_repr = val
        obj_len = len(self.__str_repr)
        self.__is_representable = obj_len < PyExpr.MAX_STRING_PRESENTATION
        if self.__is_representable:
            self.__reason = ""
        else:
            self.__reason = "Too long (Length={}). ".format(obj_len)

    def get_str_repr_abridged(self):
        """
        Returns only the first MAX_STRING_PRESENTATION characters of the str_repr
        :return: The abridged str_repr
        """
        ext = ""
        if len(self.__str_repr) > PyExpr.MAX_STRING_PRESENTATION:
            ext = "..."

        return self.__str_repr[:PyExpr.MAX_STRING_PRESENTATION] + ext

    def is_representable(self):
        return self.__is_representable

    def get_reason(self):
        """
        Gets the reason why the object is not representable.
        :return: The reason
        """
        return self.__reason

    def get_pending(self) -> bool:
        """
        Indicates whether if the given obj has passed repr and eval round trip.
        :return: True - passed.
        """
        return self.__pending

    def set_pending(self, pending: bool):
        """
        Sets the state if it is known the given obj has passed repr and eval round trip.
        :param pending: True - passed.
        """
        self.__pending = pending

    # --------------------------- instance PUBLIC properties ----------------------------
    obj = property(get_obj, set_obj)
    str_repr = property(get_str_repr, set_str_repr)
    str_repr_abridged = property(get_str_repr_abridged)
    reason = property(get_reason)
    pending = property(get_pending, set_pending)

    # --------------------------- instance __SPECIAL__ method overrides -------------------------

    def __str__(self):
        """
        Returns the internal data to the outside world as a user friendly format.
        :return: A repr() of the internal data or its abridged version, or ''
        """
        if self.__pending:
            return "Pending: please don't use this value until it is constructed."

        if self.is_representable():
            if self.__str_repr == repr(""):
                #  It is empty string. We could show '', but it looks more natural to show nothing.
                return ''
            else:
                return self.str_repr
        else:
            return self.str_repr_abridged


class PathExprValidator(QValidator):
    """
    Validates the string in the given QLineEdit according to the syntax of the Python expressions. The
    validation happens while the text is changed. When it is invalid, the QLineEdit will be highlighted as red.

    The validation result is also emitted as a signal.
    """

    # --------------------------- class-wide data and signals -----------------------------------

    # True - the text in the QLineEdit is valid; otherwise, invalid
    sig_path_valid = pyqtSignal(str, bool)

    # --------------------------- instance (self) PUBLIC methods --------------------------------

    def __init__(self, validation_target: QLineEdit = None, relative_to_folder: QCheckBox = False,
                 scenario_folder: str = None, parent: QObject = None, accept_empty_expr: bool = False):
        """
        The constructor uses the obj to initialize the all the properties of this class.
        :param validation_target: the string need to be validated
        :param relative_to_folder: flag if the path is relative to scenario
        :param scenario_folder: a string represents the scenario path
        :param parent: [optional] The widget from which text box is spawned.
        :param accept_empty_expr: flag if empty string is accepted
        """
        super().__init__(parent)
        self.__validation_target = validation_target
        self.__accept_empty_expr = accept_empty_expr
        self.__is_relative_to_folder = relative_to_folder.isChecked()
        self.__scenario_folder = str(scenario_folder)
        if validation_target is not None:
            validation_target.textChanged.connect(self.__slot_on_text_changed)
            relative_to_folder.stateChanged.connect(self.__slot_on_text_changed)

            # It is not needed, but set just in case the Qt expects something.
            validation_target.setValidator(self)
        else:
            self.__validation_target.setStyleSheet('QLineEdit { background-color: red }')

    def set_relative_to_folder(self, relative: int):
        self.__is_relative_to_folder = relative

    @override(QValidator)
    def validate(self, path_str: str, pos: int) -> QValidator.State:
        """
        Validates the string in the given QLineEdit see if it's valid path string.
        """
        if not path_str:
            if self.__accept_empty_expr:
                return QValidator.Acceptable, path_str, pos
            else:
                self.__validation_target.setStyleSheet('QLineEdit { background-color: red }')
                return QValidator.Intermediate, path_str, pos

        if not check_valid_file_path(path_str):
            return QValidator.Intermediate, path_str, pos

        if self.__is_relative_to_folder and (not is_path_below_directory(path_str, self.__scenario_folder)):
            return QValidator.Intermediate, path_str, pos
        else:
            return QValidator.Acceptable, path_str, pos

    # --------------------------- instance __PRIVATE members-------------------------------------

    def __on_text_changed(self):
        """
        Changes colors ane emits the sig_params_valid, based on the validation.
        This is called while the user is typing.
        """
        validity, _, _ = self.validate(self.__validation_target.text(), 0)
        colors = {QValidator.Invalid: 'red', QValidator.Intermediate: 'red'}
        if validity in colors:
            self.__validation_target.setStyleSheet('QLineEdit {{ background-color: {} }}'.format(colors[validity]))
            self.sig_path_valid.emit(self.objectName(), False)
        else:
            self.__validation_target.setStyleSheet(None)
            self.sig_path_valid.emit(self.objectName(), True)

    __slot_on_text_changed = safe_slot(__on_text_changed)


class ImportSourceModuleExprValidator(QValidator):
    """
    Validates the string in the given QLineEdit according to the syntax of the Python expressions. The
    validation happens while the text is changed. When it is invalid, the QLineEdit will be highlighted as red.

    The validation result is also emitted as a signal.
    """

    # --------------------------- class-wide data and signals -----------------------------------

    # True - the text in the QLineEdit is valid; otherwise, invalid
    sig_module_valid = pyqtSignal(str, bool)

    # --------------------------- instance (self) PUBLIC methods --------------------------------

    def __init__(self, validation_target: QLineEdit = None, parent: QObject = None, accept_empty_expr: bool = False):
        """
        The constructor uses the obj to initialize the all the properties of this class.
        :param validation_target: the string need to be validated
        :param parent: [optional] The widget from which text box is spawned.
        :param accept_empty_expr: flag if empty string is accepted
        """
        super().__init__(parent)
        self.__validation_target = validation_target
        self.__accept_empty_expr = accept_empty_expr
        if validation_target is not None:
            validation_target.textChanged.connect(self.__slot_on_text_changed)

            # It is not needed, but set just in case the Qt expects something.
            validation_target.setValidator(self)
        else:
            self.__validation_target.setStyleSheet('QLineEdit { background-color: red }')

    @override(QValidator)
    def validate(self, module_str: str, pos: int) -> QValidator.State:
        """
        Validates the string in the given QLineEdit see if it's valid import module string.
        """
        if not module_str:
            if self.__accept_empty_expr:
                return QValidator.Acceptable, module_str, pos
            else:
                self.__validation_target.setStyleSheet('QLineEdit { background-color: red }')
                return QValidator.Intermediate, module_str, pos

        try:
            importlib.util.find_spec(module_str)
        except Exception:
            # Exeception when 'xxx.' entered, and 'xxx' is not a package
            return QValidator.Intermediate, module_str, pos
        else:
            if importlib.util.find_spec(module_str) is None:
                return QValidator.Intermediate, module_str, pos
            else:
                return QValidator.Acceptable, module_str, pos

    # --------------------------- instance __PRIVATE members-------------------------------------
    def __on_text_changed(self):
        """
        Changes colors ane emits the sig_params_valid, based on the validation.
        This is called while the user is typing.
        """
        validity, _, _ = self.validate(self.__validation_target.text(), 0)
        colors = {QValidator.Invalid: 'red', QValidator.Intermediate: 'red'}
        if validity in colors:
            self.__validation_target.setStyleSheet('QLineEdit {{ background-color: {} }}'.format(colors[validity]))
            self.sig_module_valid.emit(self.objectName(), False)
        else:
            self.__validation_target.setStyleSheet(None)
            self.sig_module_valid.emit(self.objectName(), True)

    __slot_on_text_changed = safe_slot(__on_text_changed)


class PythonNameValidator(QValidator):
    """
    Validates the string in the given QLineEdit is valid Python name. The validation happens
    while the text is changed. When it is invalid, the QLineEdit will be highlighted as red.

    The validation result is also emitted as a signal.
    """

    # --------------------------- class-wide data and signals -----------------------------------

    # True - the text in the QLineEdit is valid; otherwise, invalid
    sig_str_valid = pyqtSignal(str, bool)

    # --------------------------- instance (self) PUBLIC methods --------------------------------

    def __init__(self, validation_target: QLineEdit = None, parent: QObject = None, accept_empty_expr: bool = True):
        """
        The constructor uses the obj to initialize the all the properties of this class.
        :param validation_target: the string need to be validated
        :param parent: [optional] The widget from which text box is spawned.
        :param accept_empty_expr: flag if empty string is accepted
        """
        super().__init__(parent)
        self.__validation_target = validation_target
        self.__accept_empty_expr = accept_empty_expr
        if validation_target is not None:
            validation_target.textChanged.connect(self.__slot_on_text_changed)

            # It is not needed, but set just in case the Qt expects something.
            validation_target.setValidator(self)
        else:
            self.__validation_target.setStyleSheet('QLineEdit { background-color: red }')

    @override(QValidator)
    def validate(self, input_str: str, pos: int) -> QValidator.State:
        """
        Validates the string in the given QLineEdit see if it's valid import module string.
        """
        if not input_str:
            if self.__accept_empty_expr:
                return QValidator.Acceptable, input_str, pos
            else:
                self.__validation_target.setStyleSheet('QLineEdit { background-color: red }')
                return QValidator.Intermediate, input_str, pos

        if input_str.isidentifier():
            return QValidator.Acceptable, input_str, pos
        else:
            return QValidator.Intermediate, input_str, pos

    # --------------------------- instance __PRIVATE members-------------------------------------
    def __on_text_changed(self):
        """
        Changes colors ane emits the sig_params_valid, based on the validation.
        This is called while the user is typing.
        """
        validity, _, _ = self.validate(self.__validation_target.text(), 0)
        colors = {QValidator.Invalid: 'red', QValidator.Intermediate: 'red'}
        if validity in colors:
            self.__validation_target.setStyleSheet('QLineEdit {{ background-color: {} }}'.format(colors[validity]))
            self.sig_str_valid.emit(self.objectName(), False)
        else:
            self.__validation_target.setStyleSheet(None)
            self.sig_str_valid.emit(self.objectName(), True)

    __slot_on_text_changed = safe_slot(__on_text_changed)